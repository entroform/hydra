function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function getRandomInteger(min, max) {
  var ceilMin = Math.ceil(min);
  var floorMax = Math.floor(max);
  return Math.floor(Math.random() * (floorMax - ceilMin + 1)) + ceilMin;
}
function getMaxArraysLength() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }

  return Math.max.apply(Math, _toConsumableArray(arrays.map(function (array) {
    return array.length;
  })));
}

function snapToInterval(value, interval) {
  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var sign = Math.sign(value) || 1;
  var valueFromOrigin = Math.abs(value - origin);

  var _interval = Math.abs(interval);

  var _value = Math.abs(value);

  var remainder = valueFromOrigin % _interval;
  var result = remainder >= _interval / 2 ? _value - remainder + _interval : _value - remainder;
  return result * sign;
}
function average() {
  if (arguments.length < 2) {
    throw new Error('Num.average: Expects at least two numbers.');
  }

  return sum.apply(void 0, arguments) / arguments.length;
}
function clamp(value, a, b) {
  var range;

  if (typeof a === 'number' && typeof b === 'number') {
    range = orderRangeArray([a, b]);
  } else if (isNumberOrRange(a) === true && typeof b === 'undefined') {
    range = getRangeFromNumberOrRange(a);
  } else {
    return value;
  }

  var _orderRangeArray = orderRangeArray(range),
      _orderRangeArray2 = _slicedToArray(_orderRangeArray, 2),
      min = _orderRangeArray2[0],
      max = _orderRangeArray2[1];

  return Math.max(min, Math.min(value, max));
}
function countDigits(value) {
  var matches = value.toString().match(/([\d])/g);

  if (matches === null) {
    return 0;
  }

  return matches.length;
}
function cubicBezier(t, p1, cp1, cp2, p2) {
  return Math.pow(1 - t, 3) * p1 + 3 * t * Math.pow(1 - t, 2) * cp1 + 3 * t * t * (1 - t) * cp2 + t * t * t * p2;
}
function cycleNumber(value, range) {
  var _range = getRangeFromNumberOrRange(range);

  var _orderRangeArray3 = orderRangeArray(_range),
      _orderRangeArray4 = _slicedToArray(_orderRangeArray3, 2),
      min = _orderRangeArray4[0],
      max = _orderRangeArray4[1];

  if (min === 0 && max === 0) {
    return 0;
  }

  var da = getEuclideanDistance(min, max);

  if (value > max) {
    var db = getEuclideanDistance(value, max);
    var c = db % da + min;

    if (c === min) {
      return max;
    }

    return c;
  } else if (value < min) {
    var _db = getEuclideanDistance(value, min);

    var _c = max - _db % da;

    if (_c === max) {
      return min;
    }

    return _c;
  }

  return value;
}
function getEuclideanDistance(a, b) {
  if (a === b) {
    return 0;
  }

  return Math.sqrt(Math.abs((a - b) * (b - a)));
}
function getSign(value) {
  var sign = Math.sign(value);
  return sign || 1;
}
function hypotenuse(x, y) {
  if (Math.hypot) {
    return Math.hypot(x, y);
  }

  var max = Math.max(Math.abs(x), Math.abs(y));

  if (max === 0) {
    max = 1;
  }

  var min = Math.min(Math.abs(x), Math.abs(y));
  var n = min / max;
  return max * Math.sqrt(1 + n * n);
}
function lerp(t, from, to) {
  return (1 - t) * from + t * to;
}
function randomNumber(range) {
  var whole = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  range = getRangeFromNumberOrRange(range);

  if (range[0] === 0 && range[1] === 1) {
    if (whole === true) {
      return Math.floor(Math.random() * 2);
    } else {
      return parseFloat(Math.random().toFixed(fixed));
    }
  } else {
    var number = transform(Math.random(), 1, range, false);
    return parseInt(number.toFixed(0), 10);
  }
}
function reciprocal(value) {
  if (value != 0) {
    return 1 / value;
  } else {
    throw new Error('reciprocal: Division by zero.');
  }
}
function roundTo(value) {
  var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return parseFloat(value.toFixed(to));
}
function sum() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  return values.reduce(function (previous, current) {
    return previous + current;
  });
}
function sumNumberArrays() {
  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    arrays[_key2] = arguments[_key2];
  }

  var maxLength = getMaxArraysLength.apply(void 0, arrays);
  var sum = [];

  var _loop = function _loop(i) {
    sum[i] = 0;
    arrays.forEach(function (array) {
      if (typeof array[i] === 'number') {
        sum[i] += array[i];
      }
    });
  };

  for (var i = 0; i < maxLength; i++) {
    _loop(i);
  }

  return sum;
}
function transform(value, from, to) {
  var clampResult = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var _from = getRangeFromNumberOrRange(from);

  var _to = getRangeFromNumberOrRange(to);

  var result = (value - _from[0]) * ((_to[1] - _to[0]) / (_from[1] - _from[0])) + _to[0];

  if (clampResult) {
    return clamp(result, _to);
  }

  return result;
}
function numberIsWithin(value, a, b, c) {
  var range;
  var isExclusive = false;

  if (typeof a === 'number' && typeof b === 'number' && (typeof c === 'boolean' || typeof c === 'undefined')) {
    if (typeof c === 'boolean') {
      isExclusive = c;
    }

    range = orderRangeArray([a, b]);
  } else if (isNumberOrRange(a) == true && (typeof b === 'boolean' || typeof b === 'undefined')) {
    if (typeof b === 'boolean') {
      isExclusive = b;
    }

    range = getRangeFromNumberOrRange(a);
  } else {
    throw new Error('numberIsWithin: Invalid input.');
  }

  var _range2 = range,
      _range3 = _slicedToArray(_range2, 2),
      min = _range3[0],
      max = _range3[1];

  if (isExclusive === true) {
    return value > min && value < max;
  } else {
    return value >= min && value <= max;
  }
}
function getRangeFromNumberOrRange(range) {
  if (typeof range === 'number') {
    return [0, range];
  }

  return [range[0], range[1]];
}
function isNumberOrRange(thing) {
  return typeof thing === 'number' || isRangeArray(thing);
}
function isRangeArray(thing) {
  return Array.isArray(thing) === true && thing.length === 2 && thing.every(function (member) {
    return typeof member === 'number';
  });
}
function orderRangeArray(range) {
  return [Math.min.apply(Math, _toConsumableArray(range)), Math.max.apply(Math, _toConsumableArray(range))];
}

function hasUppercaseLetter() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  return values.every(function (value) {
    return value !== value.toLowerCase();
  });
}
function isKebabCase() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values[_key2] = arguments[_key2];
  }

  return values.every(function (value) {
    return hasUppercaseLetter(value) === false && value.match(/^([a-z]+|[a-z][a-z\-]+[a-z])$/g) !== null;
  });
}
function isSnakeCase() {
  for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    values[_key3] = arguments[_key3];
  }

  return values.every(function (value) {
    return hasUppercaseLetter(value) === false && value.match(/^([a-z]+|[a-z][a-z\_]+[a-z])$/g) !== null;
  });
}
function kebabCaseToCamelCase(from) {
  if (isKebabCase(from) === true) {
    return from.replace(/(\-[a-z]{1})/g, function (match) {
      return match.replace(/[\-]/g, '').toUpperCase();
    });
  }

  return from;
}
function lowercaseFirstLetter(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function match(string, regex) {
  var value = string.match(regex);

  if (!value) {
    return null;
  } else if (value.length === 1) {
    return value[0];
  }

  return value;
}
function removeExtraWhitespaces(string) {
  return string.replace(/[\s]+/g, ' ');
}
function removeNewLines(string) {
  return string.replace(/[\r\n]+/g, '');
}
function removeTabs(string) {
  return string.replace(/[\t]+/g, '');
}
function replace(string, patterns) {
  var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var result = string;

  if (isStringOrRegExpArray(patterns) === true) {
    patterns.forEach(function (pattern) {
      result = string.replace(pattern, replacement);
    });
  } else if (isStringOrRegExp(patterns) === true) {
    result = string.replace(patterns, replacement);
  }

  return result;
}
function uppercaseFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function isStringOrRegExp(thing) {
  return typeof thing === 'string' || thing instanceof RegExp;
}
function isStringOrRegExpArray(thing) {
  return Array.isArray(thing) === true && thing.every(function (member) {
    return isStringOrRegExp(member);
  });
}

function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return funcs.reduceRight(function (a, f) {
      return f(a);
    }, args);
  };
}
function composeRight() {
  for (var _len3 = arguments.length, funcs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    funcs[_key3] = arguments[_key3];
  }

  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return funcs.reduce(function (a, f) {
      return f(a);
    }, args);
  };
}
function pipe() {
  for (var _len5 = arguments.length, funcs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    funcs[_key5] = arguments[_key5];
  }

  return function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return funcs.reduce(function (a, f) {
      return f(a);
    }, args);
  };
}
function curry(func) {
  return function currify() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return args.length >= func.length ? func.apply(null, args) : currify.bind.apply(currify, [null].concat(args));
  };
}
function unary(func) {
  return function () {
    return func.call(null, arguments.length <= 0 ? undefined : arguments[0]);
  };
}
function cycleArray(array, offset) {
  var index = offset % array.length;

  if (offset < 0) {
    var remainder = Math.abs(offset) % array.length;

    if (remainder === 0) {
      index = 0;
    } else {
      index = array.length + remainder * -1;
    }
  }

  return array[index];
}
function cycleArrayNext(array) {
  var index = -1;
  return function () {
    index++;

    if (index > array.length - 1) {
      index = 0;
    }

    return array[index];
  };
}
function debounce(func, delayInSeconds) {
  var timeout;
  var delay = delayInSeconds * 1000;
  return function () {
    var _arguments = arguments,
        _this = this;

    clearTimeout(timeout);
    timeout = window.setTimeout(function () {
      return func.apply(_this, _arguments);
    }, delay);
  };
}
function delay(callback, delayInSeconds) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      callback();
      resolve();
    }, delayInSeconds * 1000);
  });
}
function fillArraysToLargestLength(filler) {
  for (var _len8 = arguments.length, arrays = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    arrays[_key8 - 1] = arguments[_key8];
  }

  var maxLength = getMaxArraysLength.apply(void 0, arrays);
  arrays.forEach(function (array) {
    while (array.length < maxLength) {
      array.push(filler);
    }
  });
  return maxLength;
}
function getMinArraysLength() {
  for (var _len9 = arguments.length, arrays = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    arrays[_key9] = arguments[_key9];
  }

  return Math.min.apply(Math, _toConsumableArray(arrays.map(function (array) {
    return array.length;
  })));
}
function isEmptyObject(object) {
  return isObject(object) && Object.keys(object).length < 1;
}
function isObject(object) {
  return object !== null && _typeof(object) === 'object';
}
function isPromise() {
  if (arguments.length === 0) {
    return false;
  }

  var isPromise = function isPromise(thing) {
    return _typeof(thing) === 'object' && typeof thing.then === 'function' && thing instanceof Promise && Promise.resolve(thing) === thing;
  };

  for (var i = 0; i < arguments.length; i++) {
    var thing = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (!isPromise(thing)) {
      return false;
    }
  }
  return true;
}
function memo(func, cache) {
  return function () {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    var key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    } else {
      var value = func.apply(void 0, args);
      cache.set(key, value);
      return value;
    }
  };
}
function promiseChain() {
  for (var _len11 = arguments.length, funcs = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
    funcs[_key11] = arguments[_key11];
  }

  return new Promise(function (resolve, reject) {
    var currentIndex = -1;

    var loop = function loop() {
      currentIndex++;

      if (typeof funcs[currentIndex] === 'function') {
        funcs[currentIndex]().then(function () {
          return loop();
        })["catch"](function (error) {
          return reject(error);
        });
      } else {
        resolve();
      }
    };

    loop();
  });
}
function promiseEach(array, func) {
  if (array.length === 0) {
    return Promise.resolve();
  }

  return array.reduce(function (previous, current) {
    return previous.then(function () {
      return func(current);
    });
  }, Promise.resolve());
}
function randomChoice() {
  for (var _len12 = arguments.length, choices = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
    choices[_key12] = arguments[_key12];
  }

  return choices[getRandomInteger(0, choices.length - 1)];
}
function sleep(timeInSeconds) {
  return new Promise(function (resolve) {
    return setTimeout(function () {
      return resolve();
    }, timeInSeconds * 1000);
  });
}
function throttle(func, thresholdInSeconds) {
  var timeout;
  var last;
  var threshold = thresholdInSeconds * 1000;
  return function () {
    var _arguments2 = arguments,
        _this2 = this;

    var now = Date.now();

    if (typeof last === 'number' && now < last + threshold) {
      clearTimeout(timeout);
      timeout = window.setTimeout(function () {
        last = now;
        func.apply(_this2, _arguments2);
      }, threshold);
    } else {
      last = now;
      func.apply(this, arguments);
    }
  };
}
function truthChain() {
  var result = true;

  for (var _len13 = arguments.length, funcs = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
    funcs[_key13] = arguments[_key13];
  }

  for (var i = 0; i < funcs.length; i++) {
    if (funcs[i]() === false) {
      result = false;
      break;
    }
  }

  return result;
}

export { average, clamp, compose, composeRight, countDigits, cubicBezier, curry, cycleArray, cycleArrayNext, cycleNumber, debounce, delay, fillArraysToLargestLength, getEuclideanDistance, getMaxArraysLength, getMinArraysLength, getRandomInteger, getRangeFromNumberOrRange, getSign, hasUppercaseLetter, hypotenuse, isEmptyObject, isKebabCase, isNumberOrRange, isObject, isPromise, isRangeArray, isSnakeCase, isStringOrRegExp, isStringOrRegExpArray, kebabCaseToCamelCase, lerp, lowercaseFirstLetter, match, memo, numberIsWithin, orderRangeArray, pipe, promiseChain, promiseEach, randomChoice, randomNumber, reciprocal, removeExtraWhitespaces, removeNewLines, removeTabs, replace, roundTo, sleep, snapToInterval, sum, sumNumberArrays, throttle, transform, truthChain, unary, uppercaseFirstLetter };
//# sourceMappingURL=piko.js.map
