{"version":3,"file":"piko.js","sources":["../../lib/shared.ts","../../lib/number.ts","../../lib/string.ts","../../lib/general.ts"],"sourcesContent":["export function getRandomInteger(min: number, max: number): number {\n  const ceilMin = Math.ceil(min);\n  const floorMax = Math.floor(max);\n  return Math.floor(Math.random() * (floorMax - ceilMin + 1)) + ceilMin;\n}\n\nexport function getMaxArraysLength(...arrays: unknown[][]): number {\n  return Math.max(...arrays.map(array => array.length));\n}","import {\n  NumberOrRange,\n  RangeArray,\n} from './interfaces';\n\nimport {\n  getMaxArraysLength,\n} from './shared';\n\nexport function snapToInterval(\n  value: number,\n  interval: number,\n  origin: number = 0,\n): number {\n  const sign = Math.sign(value) || 1;\n  const valueFromOrigin = Math.abs(value - origin);\n  const _interval = Math.abs(interval);\n  const _value = Math.abs(value);\n  const remainder = valueFromOrigin % _interval;\n  const result = remainder >= _interval / 2\n    ? _value - remainder + _interval\n    : _value - remainder;\n  return result * sign;\n}\n\nexport function average(...values: number[]): number {\n  if (values.length < 2) {\n    throw new Error ('Num.average: Expects at least two numbers.');\n  }\n\n  return sum(...values) / values.length;\n}\n\nexport function clamp(value: number, min: number, max: number): number;\nexport function clamp(value: number, range: NumberOrRange): number;\nexport function clamp(value: number, a: NumberOrRange, b?: number): number {\n  let range: RangeArray;\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    range = orderRangeArray([a, b]);\n  } else if (\n    isNumberOrRange(a) === true\n    && typeof b === 'undefined'\n  ) {\n    range = getRangeFromNumberOrRange(a);\n  } else {\n    return value;\n  }\n\n  let [min, max] = orderRangeArray(range);\n\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function countDigits(value: number): number {\n  const matches = value.toString().match(/([\\d])/g);\n\n  if (matches === null) {\n    return 0;\n  }\n\n  return matches.length;\n}\n\nexport function cubicBezier(t: number, p1: number, cp1: number, cp2: number, p2: number): number {\n  return (\n    Math.pow(1 - t, 3) * p1 +\n    3 * t * Math.pow(1 - t, 2) * cp1 +\n    3 * t * t * (1 - t) * cp2 +\n    t * t * t * p2\n  );\n}\n\nexport function cycleNumber(\n  value: number,\n  range: NumberOrRange,\n): number {\n  const _range = getRangeFromNumberOrRange(range);\n  const [min, max] = orderRangeArray(_range);\n\n  if (min === 0 && max === 0) {\n    return 0;\n  }\n\n  const da = getEuclideanDistance(min, max);\n\n  if (value > max) {\n    let db = getEuclideanDistance(value, max);\n\n    let c = (db % da) + min;\n\n    if (c === min) {\n      return max;\n    }\n\n    return c;\n  } else if (value < min) {\n    let db = getEuclideanDistance(value, min);\n\n    let c = max - (db % da);\n\n    if (c === max) {\n      return min;\n    }\n\n    return c;\n  }\n\n  return value;\n}\n\n// https://en.wikipedia.org/wiki/Euclidean_distance\nexport function getEuclideanDistance(a: number, b: number): number {\n  if (a === b) {\n    return 0;\n  }\n  return Math.sqrt(Math.abs((a - b) * (b - a)));\n}\n\nexport function getSign(value: number): number {\n  const sign = Math.sign(value);\n  return sign || 1;\n}\n\nexport function hypotenuse(x: number, y: number): number {\n  if (Math.hypot) {\n    return Math.hypot(x, y);\n  }\n\n  let max = Math.max(Math.abs(x), Math.abs(y));\n\n  if (max === 0) {\n    max = 1;\n  }\n\n  const min = Math.min(Math.abs(x), Math.abs(y));\n  const n = min / max;\n\n  return max * Math.sqrt(1 + n * n);\n}\n\nexport function lerp(t: number, from: number, to: number): number {\n  return (1 - t) * from + t * to;\n}\n\nexport function randomNumber(\n  range: NumberOrRange,\n  whole: boolean = false,\n  fixed: number = 2,\n): number {\n  range = getRangeFromNumberOrRange(range);\n\n  if (range[0] === 0 && range[1] === 1) {\n    if (whole === true) {\n      return Math.floor(Math.random() * 2);\n    } else {\n      return parseFloat(Math.random().toFixed(fixed));\n    }\n  } else {\n    const number = transform(Math.random(), 1, range, false);\n\n    return parseInt(number.toFixed(0), 10);\n  }\n}\n\nexport function reciprocal(value: number): number {\n  if (value != 0) {\n    return 1 / value;\n  } else {\n    throw new Error('reciprocal: Division by zero.');\n  }\n}\n\nexport function roundTo(value: number, to: number = 0): number {\n  return parseFloat(value.toFixed(to));\n}\n\nexport function sum(...values: number[]): number {\n  return values.reduce((previous, current) => previous + current);\n}\n\nexport function sumNumberArrays(...arrays: number[][]): number[] {\n  const maxLength = getMaxArraysLength(...arrays);\n\n  const sum: number[] = [];\n\n  for (let i = 0; i < maxLength; i++) {\n    sum[i] = 0;\n    arrays.forEach(array => {\n      if (typeof array[i] === 'number') {\n        sum[i] += array[i];\n      }\n    });\n  }\n\n  return sum;\n}\n\n// https://math.stackexchange.com/questions/377169/calculating-a-value-inside-one-range-to-a-value-of-another-range/377174\nexport function transform(\n  value: number,\n  from: NumberOrRange,\n  to: NumberOrRange,\n  clampResult: boolean = true,\n): number {\n  const _from = getRangeFromNumberOrRange(from);\n  const _to   = getRangeFromNumberOrRange(to);\n\n  // Division by zero returns Infinite in JavaScript?\n  const result = (value - _from[0]) * ((_to[1] - _to[0]) / (_from[1] - _from[0])) + _to[0];\n\n  if (clampResult) {\n    return clamp(result, _to);\n  }\n\n  return result;\n}\n\nexport function numberIsWithin(\n  value: number,\n  min: number,\n  max: number,\n  isExclusive?: boolean,\n): boolean;\n\nexport function numberIsWithin(\n  value: number,\n  range: NumberOrRange,\n  isExclusive?: boolean,\n): boolean;\n\nexport function numberIsWithin(\n  value: number,\n  a: NumberOrRange,\n  b?: number | boolean,\n  c?: boolean,\n): boolean {\n  let range: RangeArray;\n\n  let isExclusive = false;\n\n  if (\n       typeof a === 'number'\n    && typeof b === 'number'\n    && (\n         typeof c === 'boolean'\n      || typeof c === 'undefined'\n    )\n  ) {\n    if (typeof c === 'boolean') {\n      isExclusive = c;\n    }\n\n    range = orderRangeArray([a, b]);\n  } else if (\n    isNumberOrRange(a) == true\n    && (\n         typeof b === 'boolean'\n      || typeof b === 'undefined'\n    )\n  ) {\n    if (typeof b === 'boolean') {\n      isExclusive = b;\n    }\n\n    range = getRangeFromNumberOrRange(a);\n  } else {\n    throw new Error('numberIsWithin: Invalid input.');\n  }\n\n  let [min, max] = range;\n\n  if (isExclusive === true) {\n    return value > min && value < max;\n  } else {\n    return value >= min && value <= max;\n  }\n}\n\nexport function getRangeFromNumberOrRange(range: NumberOrRange): RangeArray {\n  if (typeof range === 'number') {\n    return [0, range];\n  }\n\n  return [range[0], range[1]];\n}\n\nexport function isNumberOrRange(thing: any): boolean {\n  return typeof thing === 'number' || isRangeArray(thing);\n}\n\nexport function isRangeArray(thing: any): boolean {\n  return (\n    Array.isArray(thing) === true\n    && thing.length === 2\n    && thing.every(member => typeof member === 'number')\n  );\n}\n\nexport function orderRangeArray(range: RangeArray): RangeArray {\n  return [Math.min(...range), Math.max(...range)];\n}\n","export type StringOrRegExp = string | RegExp;\n\nexport function hasUppercaseLetter(...values: string[]): boolean {\n  return values.every(value => value !== value.toLowerCase());\n}\n\nexport function isKebabCase(...values: string[]): boolean {\n  return values.every(value => (\n    hasUppercaseLetter(value) === false\n    && value.match(/^([a-z]+|[a-z][a-z\\-]+[a-z])$/g) !== null\n  ));\n}\n\nexport function isSnakeCase(...values: string[]): boolean {\n  return values.every(value => (\n    hasUppercaseLetter(value) === false\n    && value.match(/^([a-z]+|[a-z][a-z\\_]+[a-z])$/g) !== null\n  ));\n}\n\nexport function kebabCaseToCamelCase(from: string): string {\n  if (isKebabCase(from) === true) {\n    return from.replace(/(\\-[a-z]{1})/g, match => (\n      match.replace(/[\\-]/g, '')\n           .toUpperCase()\n    ));\n  }\n\n  return from;\n}\n\nexport function lowercaseFirstLetter(string: string): string {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nexport function match(string: string, regex: RegExp): string | string[] | null {\n  const value = string.match(regex);\n\n  if (!value) {\n    return null;\n  } else if (value.length === 1) {\n    return value[0];\n  }\n\n  return value;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace_in_the_DOM\nexport function removeExtraWhitespaces(string: string): string {\n  return string.replace(/[\\s]+/g, ' ');\n}\n\nexport function removeNewLines(string: string): string {\n  return string.replace(/[\\r\\n]+/g, '');\n}\n\nexport function removeTabs(string: string): string {\n  return string.replace(/[\\t]+/g, '');\n}\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter\nexport function replace(\n  string: string,\n  patterns: StringOrRegExp,\n  replacement: string | Function,\n): string\n\nexport function replace(\n  string: string,\n  patterns: StringOrRegExp[],\n  replacement: string | Function,\n): string\n  \nexport function replace(\n  string: string,\n  patterns: StringOrRegExp | StringOrRegExp[],\n  replacement: string | Function = '',\n): string {\n  let result: string = string;\n\n  if (isStringOrRegExpArray(patterns) === true) {\n    (patterns as StringOrRegExp[]).forEach(pattern => {\n      result = string.replace(pattern, replacement as string);\n    });\n  } else if (isStringOrRegExp(patterns) === true) {\n    result = string.replace(patterns as StringOrRegExp, replacement as string);\n  }\n\n  return result;\n}\n\nexport function uppercaseFirstLetter(string: string): string {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nexport function isStringOrRegExp(thing: any): boolean {\n  return typeof thing === 'string' || thing instanceof RegExp;\n}\n\nexport function isStringOrRegExpArray(thing: any): boolean {\n  return (\n    Array.isArray(thing) === true\n    && thing.every(member => isStringOrRegExp(member))\n  );\n}\n","import {\n  getMaxArraysLength,\n  getRandomInteger,\n} from './shared';\n\nexport function compose<T = any>(...funcs: Function[]) {\n  return (...args: T[]) => funcs.reduceRight((a, f) => f(a), args);\n}\n\n// This works too:\n// const compose = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));\nexport function composeRight<T = any>(...funcs: Function[]) {\n  return (...args: T[]) => funcs.reduce((a, f) => f(a), args);\n}\n\n// Another name for composeRight:\nexport function pipe<T = any>(...funcs: Function[]) {\n  return (...args: T[]) => funcs.reduce((a, f) => f(a), args);\n}\n\nexport function curry<T = any>(func: Function): Function {\n  return function currify(...args: T[]): Function {\n    return (args.length >= func.length)\n      ? func.apply(null, args)\n      : currify.bind(null, ...args);\n  }\n}\n\nexport function unary<T = any>(func: Function): Function {\n  return (...args: T[]) => func.call(null, args[0]);\n}\n\n/**\n * Cycles through the array from the given offset number.\n * The offset number represents a cycled index of the array.\n * \n * @typeparam A The type of array passed in.\n * @param array - The array that you want to cycle through.\n * @param offset - Array index offset.\n * @returns A cycled offsetted array value.\n */\nexport function cycleArray<A>(array: A[], offset: number): A {\n  let index = offset % array.length;\n\n  if (offset < 0) {\n    const remainder = Math.abs(offset) % array.length;\n\n    if (remainder === 0) {\n      index = 0;\n    } else {\n      index = array.length + remainder * -1;\n    }\n  }\n\n  return array[index];\n}\n\n/**\n * Enter an array of specified type and this returns a cycle array next function.\n * Each time you call the returned function it will cycle through the array starting from the first item.\n * \n * @param array - The array that you want to cycle through.\n * @returns A function that when you call returns the next item in the array.\n */\nexport function cycleArrayNext<A>(array: A[]): Function {\n  let index = -1;\n\n  return function () {\n    index++;\n\n    if (index > array.length - 1) {\n      index = 0;\n    }\n\n    return array[index];\n  };\n}\n\n/**\n * Returns a debounce function. Delay is in seconds. \n * \n * Debouncing is often used to improve browsers performance, but it has many other uses too.\n * \n * A debounce function is a function that only fires after a certain amount of time have passed.\n * Usually, this function is bound to an event that fires multiple times really fast.\n * If the time between those events is smaller than the debounce delay,\n * the function won't fire until the firing stops the delay time elapsed.\n * This is useful for detecting or only do something only once event firing has stopped.\n * \n * @param func - Function that you want to fire after a certain amont of time have passed.\n * @param delayInSeconds - Delay, in seconds, before the function can fire between previous function call.\n * @returns A debounce function.\n */\nexport function debounce(func: Function, delayInSeconds: number): Function {\n  let timeout: number;\n\n  const delay = delayInSeconds * 1000;\n\n  return function() {\n    clearTimeout(timeout);\n\n    timeout = window.setTimeout(\n      () => func.apply(this, arguments),\n      delay\n    );\n  };\n}\n\nexport function delay(callback: Function, delayInSeconds: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(\n      () => {\n        callback();\n        resolve();\n      },\n      delayInSeconds * 1000\n    );\n  });\n}\n\nexport function fillArraysToLargestLength(filler: unknown, ...arrays: unknown[][]): number {\n  const maxLength = getMaxArraysLength(...arrays);\n\n  arrays.forEach(array => {\n    while (array.length < maxLength) {\n      array.push(filler);\n    }\n  });\n\n  return maxLength;\n}\n\n\nexport function getMinArraysLength(...arrays: unknown[][]): number {\n  return Math.min(...arrays.map(array => array.length));\n}\n\nexport function isEmptyObject(object: any): boolean {\n  return (\n    isObject(object)\n    && Object.keys(object).length < 1\n  );\n}\n\nexport function isObject(object: any): boolean {\n  return (\n    object !== null\n    && typeof object === 'object'\n  );\n}\n\nexport function isPromise(...things: any[]): boolean {\n  if (things.length === 0) {\n    return false;\n  }\n\n  const isPromise = thing => {\n    return (\n      typeof thing === 'object'\n      && typeof thing.then === 'function'\n      && thing instanceof Promise\n      && Promise.resolve(thing) === thing\n    );\n  }\n\n  for (let i = 0; i < things.length; i++) {\n    const thing = things[i];\n\n    if (!isPromise(thing)) {\n      return false;\n    }\n  };\n\n  return true;\n}\n\nexport function memo<T>(func: Function, cache: Map<string, T>) {\n  return (...args) => {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    } else {\n      const value = func(...args);\n      cache.set(key, value);\n      return value;\n    }\n  }\n}\n\nexport function promiseChain(...funcs: (() => Promise<void>)[]): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let currentIndex = -1;\n\n    const loop = () => {\n      currentIndex++;\n\n      if (typeof funcs[currentIndex] === 'function') {\n        funcs[currentIndex]()\n          .then(() => loop())\n          .catch(error => reject(error));\n      } else {\n        resolve();\n      }\n    }\n\n    loop();\n  });\n}\n\nexport function promiseEach<A>(array: A[], func: (value: A) => Promise<void>): Promise<void> {\n  if (array.length === 0) {\n    return Promise.resolve();\n  }\n\n  return array.reduce(\n    (previous: Promise<void>, current: A) => {\n      return previous.then(() => func(current));\n    },\n    Promise.resolve(),\n  );\n}\n\nexport function randomChoice<A>(...choices: A[]): A {\n  return choices[getRandomInteger(0, choices.length - 1)];\n}\n\nexport function sleep(timeInSeconds: number): Promise<void> {\n  return new Promise(resolve => setTimeout(() => resolve(), timeInSeconds * 1000));\n}\n\nexport function throttle(func: Function, thresholdInSeconds: number): Function {\n  let timeout: number;\n  let last: number;\n\n  const threshold = thresholdInSeconds * 1000;\n\n  return function() {\n    const now = Date.now();\n\n    if (typeof last === 'number' && now < last + threshold) {\n      clearTimeout(timeout);\n\n      timeout = window.setTimeout(\n        () => {\n          last = now;\n          func.apply(this, arguments);\n        },\n        threshold\n      );\n    } else {\n      last = now;\n\n      func.apply(this, arguments);\n    }\n  };\n}\n\nexport function truthChain(...funcs: (() => boolean)[]): boolean {\n  let result = true;\n\n  for (let i = 0; i < funcs.length; i++) {\n    if (funcs[i]() === false) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}"],"names":["getRandomInteger","min","max","ceilMin","Math","ceil","floorMax","floor","random","getMaxArraysLength","arrays","map","array","length","snapToInterval","value","interval","origin","sign","valueFromOrigin","abs","_interval","_value","remainder","average","arguments","Error","sum","clamp","a","b","range","orderRangeArray","isNumberOrRange","getRangeFromNumberOrRange","countDigits","matches","toString","match","cubicBezier","t","p1","cp1","cp2","p2","pow","cycleNumber","da","getEuclideanDistance","c","sqrt","getSign","hypotenuse","x","y","hypot","n","lerp","from","to","randomNumber","whole","fixed","parseFloat","toFixed","number","transform","parseInt","reciprocal","roundTo","values","reduce","previous","current","sumNumberArrays","maxLength","i","forEach","clampResult","_from","_to","result","numberIsWithin","isExclusive","thing","isRangeArray","Array","isArray","every","member","hasUppercaseLetter","toLowerCase","isKebabCase","isSnakeCase","kebabCaseToCamelCase","replace","toUpperCase","lowercaseFirstLetter","string","charAt","slice","regex","removeExtraWhitespaces","removeNewLines","removeTabs","patterns","replacement","isStringOrRegExpArray","pattern","isStringOrRegExp","uppercaseFirstLetter","RegExp","compose","funcs","args","reduceRight","f","composeRight","pipe","curry","func","currify","apply","bind","unary","call","cycleArray","offset","index","cycleArrayNext","debounce","delayInSeconds","timeout","delay","clearTimeout","window","setTimeout","_this","callback","Promise","resolve","fillArraysToLargestLength","filler","push","getMinArraysLength","isEmptyObject","object","isObject","Object","keys","_typeof","isPromise","then","memo","cache","key","JSON","stringify","has","get","set","promiseChain","reject","currentIndex","loop","error","promiseEach","randomChoice","choices","sleep","timeInSeconds","throttle","thresholdInSeconds","last","threshold","now","Date","_this2","this","truthChain"],"mappings":"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"}